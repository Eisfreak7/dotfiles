#! /bin/bash
# Use taskwarrior in combination with the pomodoro technique.
# the arguments are passed to taskwarrior as a filter

get_uuid() {
	local old=$IFS
	IFS=$'\n'
	local result=""
	# the surrounding parenthesis turn the newline-seperated tasks in the format
	# uuid:description into an array
	local uuids=($(task rc.gc=off rc.verbose=no status:pending _zshuuids "$@" 2>/dev/null))
	local count=${#uuids[@]}
	if [[ $count -eq 0 ]]; then
		echo "No item matches this filter."
		exit 1
	elif [[ $count -gt 1 ]]; then
		echo "The filter is ambigous. Please select a match out of the following:"
		local counter=0
		for task in ${uuids[@]}; do
			# Echo the index and the description
			echo "[$counter] ${task#*:}"
			((counter++))
		done
		read -r selection
		result=${uuids[$selection]}
	else
		result=${uuids[0]}
	fi
	IFS=$old
	# return only the uuid
	uuid=${result%:*}
}

play_sound_notification() {
	resume_cmd=""
	if [[ $(mpv status | grep 'playing' | wc -l) -gt 0 ]]; then
		resume_cmd="mpc play"
		mpc pause;
	fi
	mpv "$1" >/dev/null 2>&1
	eval $resume_cmd
}

get_uuid "$@"
echo "Starting pomodoro timer for the following task:"
task rc.gc=off rc.verbose=no status:pending ls "$uuid" 2>/dev/null
trap 'break' SIGTERM SIGINT # TODO: stop task
for i in 2 3 4; do
	task start "$uuid" 2>/dev/null
	# Needs the countdown script
	countdown --pauseStartCmd "task stop \"$uuid\"" --pauseStopCmd "task start \"$uuid\"" '25m'
	play_sound_notification '/usr/share/sounds/freedesktop/stereo/complete.oga'
	if [[ "$?" == 0 ]]; then # Only ask when countdown exited normally (no abort)
		notify-send --app-name=Pomodoro "Time's up" "Time to relax"
		echo "Enough."
		read -r -n1 -p "Finished working? Press any key to continue." item
		echo # newline
	fi
	task stop "$uuid" 2>/dev/null
	if [[ $i == 4 ]]; then # Don't pause the last time
		break
	fi
	case "$item" in
		n|N) break;;
		*) countdown 5m;;
	esac
	play_sound_notification '/usr/share/sounds/freedesktop/stereo/bell.oga'
	notify-send --app-name=Pomodoro "Time's up" "Time to work"
	echo "Time for round $i."
	read -r -n 1 -p "Ready? [Y/n]" item
	echo # newline
	case "$item" in
		n|N) break;;
	esac
done

if [[ $(task active "$uuid" 2>/dev/null | wc -l) != 0 ]]; then # Only stop when active
	task stop "$uuid" 2>/dev/null
fi
read -r -n 1 -p "Task done? [y/N]" item
echo # newline
case "$item" in
	y|Y) task done "$uuid" 2>/dev/null;;
esac
